# 13. Design Decisions: RDB Persistence

## 1. Objective

Implement persistence for SkylerRedis by creating and reading RDB (Redis Database) files. The primary goal is to save the entire state of the in-memory database—including keys, values, and their expiration times—to a compact binary file upon shutdown and to restore this state from the file upon startup.

## 2. Possible Solutions for the File Format

### Solution 1: Text-based Format (e.g., JSON, CSV)

-   **Structure:** Save each key-value pair as an object in a JSON file or a line in a CSV file.
    ```json
    [
      {"key": "mykey", "value": "myvalue", "expires_at": 1672531199000},
      {"key": "anotherkey", "value": "anothervalue", "expires_at": null}
    ]
    ```
-   **Pros:** It's human-readable and can be easily modified by hand. It is also simple to generate and parse using standard libraries available in any language.
-   **Cons:** This approach results in very large files, consuming significant disk space and leading to slow I/O operations. Parsing text is much slower than parsing a binary format. It is completely incompatible with Redis.

### Solution 2: Simple, Custom Binary Format

-   **Structure:** Define a straightforward, custom binary structure. For example, each record could follow a pattern like: `[4-byte key length][key][4-byte value length][value][8-byte expiry timestamp]`.
-   **Pros:** The file size is much more compact than text-based formats. Read and write speeds are significantly faster as no text processing is required.
-   **Cons:** It remains incompatible with Redis. It requires custom code for serialization and deserialization, which can be error-prone and difficult to maintain if the structure evolves.

### Solution 3: Adhere to the Official Redis RDB Format

-   **Structure:** Precisely implement the highly optimized and complex binary format that Redis itself uses.
    -   **Header:** The file must always begin with a magic string `REDIS` and a version number, for example, `REDIS0009`.
    -   **Opcodes:** Single bytes are used as markers for different types of metadata or data structures. Examples from the test cases include:
        -   `0xFE`: Opcode to select a database.
        -   `0xFD`: Opcode for an expiration time in seconds.
        -   `0xFC`: Opcode for an expiration time in milliseconds.
        -   `0x00`: Opcode signaling the start of a String key-value pair.
        -   `0xFF`: Opcode for the End Of File.
    -   **Length-Encoding:** A special length-prefixed encoding scheme is used to store the length of strings in an extremely space-efficient manner.
-   **Pros:** It is 100% compatible with Redis, allowing SkylerRedis to read `.rdb` files generated by a real Redis server and vice-versa. The format is extremely compact, and processing is very fast.
-   **Cons:** This is the most complex solution to implement. It requires a deep understanding of the RDB format specification and careful, byte-level manipulation.

## 3. Trade-off Analysis

| Solution | File Size | Read/Write Speed | Implementation Complexity | Redis Compatibility |
| :--- | :--- | :--- | :--- | :--- |
| 1. JSON/Text | **Very Large** | **Slow** | **Very Low** | **None** |
| 2. Custom Binary | **Medium** | **Fast** | **Medium** | **None** |
| 3. RDB Format | **Very Small** | **Very Fast** | **Very High** | **Full** |

## 4. SkylerRedis's Choice and Rationale

**Choice:** **Solution 3: Adhere to the Redis RDB Format.**

**Rationale:**

1.  **Compatibility Requirement:** The core goal of SkylerRedis is to be a Redis clone. The ability to read and write the standard RDB format is a non-negotiable requirement, as emphasized by the project's test cases (which check for the `REDIS0009` header, opcodes, etc.). This allows SkylerRedis to be a drop-in replacement or a participant in a real-world Redis ecosystem.
2.  **Maximum Efficiency:** The RDB format is engineered for maximum compactness and speed. For an in-memory database, minimizing I/O time during startup (reading the file) and shutdown (writing the file) is critical for ensuring low downtime and a good user experience.
3.  **Completeness and Extensibility:** The RDB format already defines how to store all of Redis's complex data structures (Lists, Hashes, Sets, ZSets, etc.). By adhering to the format from the outset, SkylerRedis paves the way to consistently support persistence for these other data types in the future. Despite the high implementation complexity, it is a worthy investment for a true Redis clone.
